# AGENTS.md

## Project Context

ObservableDefaults is a Swift 6 package that integrates SwiftUI Observation with two storage backends:

- `@ObservableDefaults` for `UserDefaults`
- `@ObservableCloud` for `NSUbiquitousKeyValueStore`

The package has two core targets:

- `Sources/ObservableDefaults`: public macros, runtime wrappers, test-mode cloud mock
- `Sources/ObservableDefaultsMacros`: SwiftSyntax macro implementations and diagnostics

Most changes are correctness-sensitive because public behavior is generated by macros and then executed through runtime wrappers. When changing behavior, inspect both the macro expansion logic and the runtime wrapper behavior before editing.

## Key Files

- `Package.swift`: package targets and SwiftSyntax dependency range
- `Sources/ObservableDefaults/Macros.swift`: public macro declarations and user-facing parameter docs
- `Sources/ObservableDefaults/UserDefaults/UserDefaultsWrapper.swift`: `UserDefaults` read/write resolution rules
- `Sources/ObservableDefaults/NSUbiquitousKeyValueStore/NSUbiquitousKeyValueStoreWrapper.swift`: cloud read/write resolution rules and DEBUG test-mode isolation
- `Sources/ObservableDefaultsMacros/Macros/ObservableDefaultsMacro.swift`: generated `UserDefaults` observation and external change handling
- `Sources/ObservableDefaultsMacros/Macros/ObservableCloudMacro.swift`: generated cloud observation logic
- `Sources/ObservableDefaultsMacros/Macros/DefaultsBackedMacro.swift`: generated `UserDefaults` accessor behavior and declaration-time default capture
- `Sources/ObservableDefaultsMacros/Macros/CloudBackedMacro.swift`: generated cloud accessor behavior
- `Tests/ObservableDefaultsTests`: authoritative behavior coverage
- `README.md` and `README_zh.md`: public semantics and usage docs

## Development Rules

### Macro and Runtime Semantics

- Do not mix `@ObservableDefaults` and `@ObservableCloud` on the same class. Keep storage concerns split across separate types.
- Both top-level macros are class-only. Do not introduce examples or tests that suggest struct support.
- `@DefaultsBacked` and `@CloudBacked` do not support `willSet` / `didSet`. `@ObservableOnly` does.
- In `observeFirst: true` mode, only explicitly backed properties are persistent. Observable-only properties must not appear in external storage notification handling.
- Prefix values are trimmed and must not contain `"."`. Preserve this invariant.
- Static properties must remain ignored by persistence/observation generation.

### Default and Fallback Behavior

- Declaration-time defaults are immutable model defaults. They are not the same as current runtime values.
- `@ObservableDefaults` fallback order is:
  1. persisted value in the selected `UserDefaults` domain
  2. value from `UserDefaults.register(defaults:)`
  3. declaration-time model default captured by the macro
- `@ObservableCloud` fallback order is:
  1. persisted cloud value
  2. declaration-time model default
- When fixing key-removal or missing-key behavior, verify both non-optional and optional properties.
- Never use the current cached property value as the fallback when recomputing external `UserDefaults` changes.

### Storage Resolution Rules

- RawRepresentable-based storage takes priority over Codable JSON storage when multiple conformances match.
- For hybrid `RawRepresentable & PropertyListValue` types, maintain raw-value write behavior and compatibility fallback on reads.
- If you change overload ordering or wrapper dispatch, run the ambiguity and compatibility suites before considering the change complete.

## Testing Expectations

- Run `swift test` before finishing any behavioral change.
- If a change touches external notifications, fallback logic, or equality checks, at minimum run:
  - `swift test --filter ExternalChangeEqualityTests`
  - `swift test --filter ObservableDefaultsTests`
- If a change touches cloud test-mode behavior, mock storage, or notification handling, also run:
  - `swift test --filter ObservableCloudTests`
  - `swift test --filter Issue26OverloadAmbiguityTests`
- If a change touches prefixes, suite parsing, or macro string parameters, run:
  - `swift test --filter PrefixTests`
  - `swift test --filter WhitespaceTests`
  - `swift test --filter StringParameterTests`
- If a change touches storage format or overload resolution, run:
  - `swift test --filter RawRepresentableCodableTests`
  - `swift test --filter Issue26OverloadAmbiguityTests`

### Test Isolation Rules

- `UserDefaults` tests should use isolated suite names. Prefer `UserDefaults.getTestInstance(suiteName:)`, and use a unique suite per test when cross-test interference is possible.
- Cloud `.testMode` tests use per-test mock suite isolation through `NSUbiquitousKeyValueStoreWrapper.testSuiteName`. Preserve that mechanism.
- If a suite relies on shared notifications or shared storage state, make it `.serialized`.
- Do not “fix” flaky tests by weakening expectations if the real issue is shared storage or notification interference.

## Documentation Rules

- If you change public behavior, update `README.md` and `README_zh.md` in the same change.
- If you change public macro parameters, update:
  - `Sources/ObservableDefaults/Macros.swift`
  - `README.md`
  - `README_zh.md`
- If you change fallback semantics, `observeFirst`, App Group behavior, or development/test mode behavior, update the README examples and explanatory sections, not just inline comments.

## Review Priorities

When reviewing changes, prioritize:

1. behavioral regressions in generated code
2. missing tests for external changes and fallback paths
3. `MainActor` and `defaultIsolationIsMainActor` coverage
4. `observeFirst` correctness
5. storage format compatibility for RawRepresentable/Codable hybrids
6. test isolation and notification scope

## Release Workflow

- Bug fixes should normally increment the patch version.
- Current release style uses plain semantic version tags such as `1.8.3`, not `v1.8.3`.
- Before tagging a release:
  - merge the intended commits into `main`
  - run full `swift test`
  - confirm `README.md` and `README_zh.md` reflect any public semantic changes
- After tagging:
  - push `main`
  - push the tag
  - create a GitHub release with notes
- Release notes should summarize:
  - the user-visible fix
  - any fallback or compatibility semantics that changed or were clarified
  - test coverage added
  - documentation updates
- If a release includes an external PR, explicitly thank the original contributor in the release notes.

## Commands

Common commands used in this repository:

```bash
swift test
swift test --filter ExternalChangeEqualityTests
swift test --filter ObservableDefaultsTests
swift test --filter ObservableCloudTests
swift test --filter Issue26OverloadAmbiguityTests
git switch main
git merge --ff-only <branch>
git tag -a 1.8.3 -m "1.8.3"
git push origin main
git push origin 1.8.3
gh release create 1.8.3 --generate-notes --title "1.8.3"
```
